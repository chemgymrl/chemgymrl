<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>chemistrylab.extract_algorithms.separate &mdash; chemistrygym 1.5.7 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            chemistrygym
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../chemistrylab.html">chemistrylab package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Installation.html">Installation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">chemistrygym</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">chemistrylab.extract_algorithms.separate</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for chemistrylab.extract_algorithms.separate</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">ceil</span>
<span class="kn">import</span> <span class="nn">numba</span>



<span class="c1"># Maximum varience of Gaussian peaks</span>


<span class="c1"># Array for x/height positions</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>


<span class="c1">#from numba.pycc import CC</span>
<span class="c1">#cc = CC(&#39;separate_cc&#39;)</span>

<div class="viewcode-block" id="map_to_state"><a class="viewcode-back" href="../../../chemistrylab.extract_algorithms.html#chemistrylab.extract_algorithms.separate.map_to_state">[docs]</a><span class="nd">@numba</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="c1">#@cc.export(&#39;map_to_state&#39;, &#39;(f4[:], f4[:],f4[:],f4[:],f4[:])&#39;)</span>
<span class="k">def</span> <span class="nf">map_to_state</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Uses the position and variance of each solvent to stochastically create a layer-view of the vessel</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        A (np.ndarray): The volume of each solvent</span>
<span class="sd">        B (np.ndarray): The current positions of the solvent layers in the vessel</span>
<span class="sd">        C (float): The current variance of the solvent layers in the vessel</span>
<span class="sd">        colors (np.ndarray): The color of each solvent</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple[np.ndarray]: </span>
<span class="sd">            - The solvent at each layer position (0.65 for air)</span>
<span class="sd">            - The index of the solvent at each position (len(B)-1 for air)</span>

<span class="sd">    Algorithm:</span>

<span class="sd">    1. Discretize the vessel into 100 layers each with one unit of volume</span>
<span class="sd">    2. Quantize the volumes into units of size sum(v)/100. (Round up agressively)</span>
<span class="sd">    3. Do a checksum to make sure these quantized volumes sum to 100</span>
<span class="sd">        i. If the sum of everything that isn&#39;t air is over 100, then decrease the solvent with the largest number of units</span>
<span class="sd">        ii. Otherwise you can just set the number of air units to 100-sum([all vi which aren&#39;t air])</span>
<span class="sd">    4. Find the position of the top layer</span>
<span class="sd">    5. For each of the quantized layers, gather the height of each gaussian at that layer position and sample a solvent proportional to this height</span>
<span class="sd">        i. This is approximately the same as doing an integral of the solvents distribution over the layer</span>
<span class="sd">        ii. Unfortunately, the solvent distributions don&#39;t add up to 1 so you have to normalize.</span>
<span class="sd">        iii. The distributions are more ballparks so you have to keep track of how many units you placed, and set the probability of the layer having a solvent to zero if all the units have already been placed</span>
<span class="sd">        iv. This also means you may not have placed all of your units by the time you are way outside the variance of your gaussian, so you should keep track of the lowest layer that still has units to place, and make sure those units are all placed once you start to go way past it.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create a copy of B for temporary changes</span>
    <span class="n">B1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
    
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="c1">#grab the index of the least dense material</span>
    <span class="n">j_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
    <span class="c1"># If there are duplicates of the least dense material jmax won&#39;t work</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="n">j_max</span><span class="p">]</span><span class="o">-</span><span class="n">B</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-4</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">j_max</span><span class="o">=-</span><span class="mi">10</span>

    <span class="c1"># Array for layers  (1.)</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="o">+</span> <span class="n">colors</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">L2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Initialize time variable such that Gaussians have normalized area</span>
    <span class="n">C</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">C</span><span class="p">,</span><span class="mf">1e-10</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>

    <span class="c1">#Note: MINP is linked to MINVAR</span>
    <span class="c1">#If you want to change one you have to change both</span>
    <span class="c1">#https://www.desmos.com/calculator/kzydc5ra3q</span>

    <span class="n">width</span> <span class="o">=</span> <span class="n">C</span><span class="o">*</span><span class="mf">3.5</span><span class="o">/</span><span class="mi">2</span>
    <span class="c1">#MINVAR is 3.5 here</span>
    <span class="n">MINP</span><span class="o">=</span><span class="mf">0.21626516683</span>

    
    <span class="n">sum_A</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="c1"># Number of pixels available for each solvent (2.)</span>
    <span class="n">n</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">n</span><span class="p">[:]</span><span class="o">=</span><span class="p">((</span><span class="n">A</span> <span class="o">/</span> <span class="n">sum_A</span><span class="p">)</span> <span class="o">*</span> <span class="n">L</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="mf">0.95</span><span class="p">))</span>
    <span class="c1"># Since this agressively rounds up, fix any rounding issues</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">n</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">L</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">count</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="c1"># 3.i</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">):</span>
            <span class="n">n</span><span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">argmax</span><span class="p">()]</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Make any unused pixels air (3.ii)</span>
        <span class="n">n</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">count</span>
    
    <span class="c1"># Loop over each layer pixel</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="c1"># Map layer pixel position to x position</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">l</span>

        <span class="c1"># 5.i</span>
        <span class="n">P_raw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(((</span><span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">)</span> <span class="o">/</span> <span class="n">C</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
        <span class="c1"># MINP is a cutoff value to set the gaussian to 0</span>
        <span class="n">P_clip</span> <span class="o">=</span> <span class="n">P_raw</span><span class="o">*</span> <span class="p">((</span><span class="n">P_raw</span> <span class="o">&gt;</span> <span class="n">MINP</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">&gt;</span><span class="n">B</span><span class="p">))</span><span class="c1">#+ P_raw*(P_raw &lt; MINP))</span>
        
        <span class="c1"># Calculate Gaussian values at current x position</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">A</span> <span class="o">/</span><span class="n">C</span> <span class="o">*</span> <span class="n">P_clip</span>
        
        <span class="c1"># Check to see if any phases have no pixels remaining</span>
        <span class="n">past_due</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">n</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Set Gaussian value to avoid placement by random set</span>
                <span class="n">P</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">P_raw</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="mf">0.0</span>
                <span class="c1"># Set Gaussian center extremely positive outside of range to avoid placement by default set</span>
                <span class="n">B1</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1e9</span>

        <span class="c1"># j_min is the index of the lowest gaussian which still has pixels to place (5.iv)</span>
        <span class="n">j_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">B1</span><span class="o">-</span><span class="n">width</span><span class="p">)</span>

        <span class="c1"># Only need to place the least dense material</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">B1</span><span class="p">)</span><span class="o">==</span><span class="n">j_max</span> <span class="ow">and</span> <span class="n">n</span><span class="p">[</span><span class="n">j_max</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">L</span><span class="p">[</span><span class="n">l</span><span class="p">:]</span> <span class="o">=</span> <span class="n">colors</span><span class="p">[</span><span class="n">j_max</span><span class="p">]</span>
            <span class="n">L2</span><span class="p">[</span><span class="n">l</span><span class="p">:]</span><span class="o">=</span><span class="n">j_max</span>
            <span class="k">return</span> <span class="n">L</span><span class="p">,</span><span class="n">L2</span>
        <span class="c1"># Sum of all Gaussians at this x position</span>
        

        <span class="c1"># Random number for mixing of layers</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span>
        <span class="n">place_jmin</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1">#Below if part 5.iv</span>
        <span class="c1"># The current point has to be far to the RIGHT of the gaussian for it to have passed over</span>
        <span class="k">if</span> <span class="n">P_clip</span><span class="p">[</span><span class="n">j_min</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">MINP</span> <span class="ow">and</span> <span class="n">n</span><span class="p">[</span><span class="n">j_min</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">&gt;</span><span class="n">B</span><span class="p">[</span><span class="n">j_min</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">P_clip</span><span class="p">[</span><span class="n">j_min</span><span class="p">]</span><span class="o">&lt;</span><span class="mf">1e-12</span><span class="p">:</span>
                <span class="n">place_jmin</span><span class="o">=</span><span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">P</span><span class="p">[</span><span class="n">j_min</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">j_min</span><span class="p">]</span> <span class="o">/</span> <span class="n">C</span><span class="p">[</span><span class="n">j_min</span><span class="p">])</span> <span class="o">*</span> <span class="n">MINP</span>
                <span class="c1">#More likely to place j_min pixels the lower it&#39;s propability is</span>
                <span class="c1">#choice_ratio = 0.1*MINP**2/P_clip[j_min]</span>
                <span class="c1">#r2=np.random.rand()</span>
                <span class="c1">#if choice_ratio&gt;=r2:</span>
                <span class="c1">#    place_jmin=True</span>

        <span class="n">Psum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>

        <span class="c1"># If x position is outside every Gaussian peak (5.iv and 5.iii)</span>
        <span class="k">if</span> <span class="n">Psum</span> <span class="o">&lt;</span> <span class="mf">1e-6</span>  <span class="ow">or</span> <span class="n">place_jmin</span><span class="p">:</span>
            <span class="c1"># Calculate the index of the most negative phase</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">j_min</span>
            <span class="c1"># Set pixel value</span>
            <span class="n">L</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">colors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">L2</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">=</span><span class="n">j</span>
            <span class="c1"># Subtract pixel for that phase</span>
            <span class="n">n</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="c1"># If x position is inside at least one Gaussian peak (5.i - 5.iii)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="c1"># Loop until pixel is set</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">p</span> <span class="o">+=</span> <span class="n">P</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="c1"># If random number is less than relative probability for that phase (5.ii)</span>
                <span class="k">if</span> <span class="n">r</span> <span class="o">-</span> <span class="n">p</span> <span class="o">/</span> <span class="n">Psum</span> <span class="o">&lt;</span> <span class="mf">1e-6</span><span class="p">:</span>
                    <span class="c1"># Set pixel value</span>
                    <span class="n">L</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">colors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">L2</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">=</span><span class="n">j</span>
                    <span class="c1"># Subtract pixel for that phase</span>
                    <span class="n">n</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="c1"># End loop</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># This code runs when the loop didn&#39;t actually set any pixels and fills it with air</span>
                <span class="n">L</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">colors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">L2</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">=</span><span class="n">j</span>
                <span class="n">n</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
    
    <span class="k">return</span> <span class="n">L</span><span class="p">,</span><span class="n">L2</span></div>


<div class="viewcode-block" id="mix"><a class="viewcode-back" href="../../../chemistrylab.extract_algorithms.html#chemistrylab.extract_algorithms.separate.mix">[docs]</a><span class="nd">@numba</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="c1">#@cc.export(&#39;mix&#39;, &#39;(f4[:], f4[:], f4[:], f4[:], f4[:], f4, f4[:], f4[:], f4[:], f4[:,:],f4)&#39;)</span>
<span class="k">def</span> <span class="nf">mix</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Vprev</span><span class="p">,</span> <span class="n">v_solute</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">C0</span> <span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">Spol</span><span class="p">,</span> <span class="n">Lpol</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">mixing</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the positions and variances of solvent layers in a vessel, as well as the new solute amounts, based on the given inputs.</span>

<span class="sd">    Args:</span>
<span class="sd">        v (np.ndarray): The volume of each solvent</span>
<span class="sd">        Vprev (np.ndarray): The volume of each solvent on the previous iteration</span>
<span class="sd">        v_solute (np.ndarray): The specific volume of each solute (litres per mol)</span>
<span class="sd">        B (np.ndarray): The current positions of the solvent layers in the vessel</span>
<span class="sd">        C (np.ndarray): The current variances of the solvent layers in the vessel</span>
<span class="sd">        C0 (float) The current variance of solutes in the vessel</span>
<span class="sd">        D (np.ndarray): The density of each solvent</span>
<span class="sd">        Spol (np.ndarray): The relative polarities of the solutes</span>
<span class="sd">        Lpol (np.ndarray): The relative polarities of the solvents</span>
<span class="sd">        S (np.ndarray): The current amounts of solutes in each solvent layer (2D array)</span>
<span class="sd">        mixing (float): The time value assigned to a fully mixed solution</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple[np.ndarray]:</span>
<span class="sd">            - layers_position: An array of floats representing the new positions of the solvent layers in the vessel</span>
<span class="sd">            - layers_variance: An array of floats representing the new variances of the solvent layers in the vessel</span>
<span class="sd">            - new_solute_amount: An array of floats representing the new amounts of solutes in each solvent layer</span>
<span class="sd">            - var_layer: Modified layer variances which account for the extra volume due to dissolved solutes</span>

<span class="sd">    Algorithm (Solvent):</span>

<span class="sd">    1. Using the volumes and densities of each solvent, determine where each solvent&#39;s center of mass should be at t-&gt; inf</span>
<span class="sd">    2. Determine the speed in which each solvent should separate out using the densities</span>
<span class="sd">    3. Handle any external changes to the solving (pouring in/out) using v and Vprev</span>
<span class="sd">        i. Since there is an injective map between variance and time, it is easier to work with variance</span>
<span class="sd">            a) Initial variance is sum(v)/sqrt(12) [gaussian approximation of a uniform distribution]</span>
<span class="sd">            b) Final variance is vi/MINVAR -&gt; MINVAR should probably be around sqrt(12) still (but be &lt;=)</span>
<span class="sd">        ii. Pouring in a solvent should kind of mix around the solution, and since the max variance is sum(v)/sqrt(12) adding in dv/sqrt(12) seems reasonable</span>
<span class="sd">        iii. For the solvent actually being added, we can assume you are pouring into the top, so it should be mixed the closer to the bottom the solvent layer is. It should also be mixed more depending on how much you are adding.</span>
<span class="sd">        iv. If adding a solvent causes things to be mixed around a bunch, it should end up mixing the solutes too</span>
<span class="sd">    4. Get a time-like variable saying much each solvent is settled using the current variance (Recall the map is injective)</span>
<span class="sd">    5. Increment this by the mixing parameter</span>
<span class="sd">        i. If time is being decreased by the mixing parameter, we first set T&lt;= Tmax so something which settled for a long time still mixes reasonably fast (and also as T-&gt;inf the map between variance and time gets sus cuz of floats)</span>
<span class="sd">    6. Use this incremented time to update your layer positions, as well as layer variances</span>

<span class="sd">    Algorithm (Solute):</span>
<span class="sd">    TODO: Write this out</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">s</span><span class="o">=</span><span class="n">C</span><span class="o">*</span><span class="mi">1</span>
    <span class="n">x</span><span class="o">=</span><span class="n">B</span><span class="o">*</span><span class="mi">1</span>
    <span class="c1"># CONSTANTS</span>
    <span class="n">MINVAR</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="mf">3.5</span><span class="p">)</span>
    <span class="n">SCALING</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="mf">1e-2</span><span class="p">)</span>
    <span class="n">t_scale</span> <span class="o">=</span> <span class="mi">25</span>
    <span class="c1">#Cmix = np.float32(2.0)</span>
    <span class="n">tmix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="o">-</span><span class="mf">1.6120857137646178</span><span class="p">)</span><span class="c1">#-1.0 * np.log(Cmix * np.sqrt(2.0 * np.pi))</span>
    <span class="n">tseparate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="o">-</span><span class="mf">1.47</span><span class="p">)</span>
    <span class="n">TOL</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="mf">1e-12</span><span class="p">)</span>
    <span class="n">E3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="mf">1e-3</span><span class="p">)</span>
    <span class="n">MAXVAR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span>

    <span class="c1"># copy mixing for the solutes in case you need to modify it</span>
    <span class="n">solute_mixing</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1">#figure out where the gaussians should end up at T-&gt; inf</span>
    <span class="n">order</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">D</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">Vtot</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="c1">#Total volume</span>



    <span class="c1">#Get convergence speeds based off of how different the densities are</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">diff</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
            <span class="n">diff</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-=</span> <span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">diff</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-=</span> <span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">diff</span><span class="p">),</span><span class="n">E3</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>

    <span class="n">max_var</span> <span class="o">=</span> <span class="n">Vtot</span><span class="o">/</span><span class="n">MAXVAR</span>
    <span class="n">solvent_mixing</span><span class="o">=</span><span class="mi">0</span>
    <span class="c1">#adjust variance</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Lpol</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="c1"># Figure out how much the volume has changed</span>
        <span class="n">dv</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">Vprev</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="c1"># Make sure variance is at least as big as fully separated variance</span>
        <span class="n">cur_var</span><span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">MINVAR</span><span class="p">)</span>
        <span class="c1"># Add some variance to each solvent</span>
        <span class="c1">#s+=dv/MAXVAR</span>
        <span class="c1"># Extra mixing dependant on the position and how much was added</span>
        <span class="k">if</span> <span class="n">dv</span><span class="o">&gt;</span><span class="mf">1e-6</span><span class="p">:</span>
            <span class="n">new_var</span> <span class="o">=</span> <span class="p">(</span><span class="n">dv</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">dv</span><span class="p">)</span><span class="o">+</span><span class="n">TOL</span><span class="p">))</span><span class="o">*</span><span class="p">((</span><span class="n">Vtot</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="n">MAXVAR</span><span class="p">)</span>
            <span class="n">new_var</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_var</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">cur_var</span><span class="p">,</span><span class="n">new_var</span><span class="p">))</span>
            <span class="c1">#mix surrounding solvents (excludes air)</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">s</span><span class="p">[:</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+=</span> <span class="n">dv</span><span class="o">/</span><span class="n">MAXVAR</span><span class="o">+</span><span class="p">(</span><span class="n">new_var</span><span class="o">-</span><span class="n">cur_var</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
            <span class="c1">#Mix solvent</span>
            <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">new_var</span>
            <span class="c1">#TODO: Set extra mixing of solutes</span>
            <span class="n">var_ratio</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_var</span><span class="o">-</span><span class="n">cur_var</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">max_var</span><span class="o">-</span><span class="n">cur_var</span><span class="p">)</span><span class="o">+</span><span class="n">TOL</span><span class="p">)</span>
            <span class="n">solute_mixing</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">solute_mixing</span><span class="p">,</span> <span class="p">(</span><span class="n">tmix</span><span class="o">-</span><span class="n">tseparate</span><span class="p">)</span><span class="o">*</span><span class="n">var_ratio</span> <span class="p">)</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_var</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">dv</span><span class="o">/</span><span class="n">MINVAR</span><span class="p">)</span> 
            
    <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">!=</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">s0</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span><span class="n">v</span><span class="o">/</span><span class="n">MINVAR</span>
        <span class="n">s</span><span class="p">[:</span><span class="n">Lpol</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">=</span><span class="n">s0</span><span class="p">[:</span><span class="n">Lpol</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

    

    <span class="c1">#Get the mixing-time variable</span>
    <span class="n">sf</span> <span class="o">=</span> <span class="n">v</span><span class="o">/</span><span class="n">MINVAR</span> <span class="c1"># final variances</span>
    <span class="n">si</span> <span class="o">=</span> <span class="n">Vtot</span><span class="o">/</span><span class="n">MAXVAR</span> <span class="c1"># initial variances</span>
    <span class="n">s</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">sf</span><span class="o">+</span><span class="n">TOL</span><span class="p">,</span><span class="n">si</span><span class="o">-</span><span class="n">TOL</span><span class="p">)</span>
    <span class="c1">#ratio -&gt; inf as t -&gt; inf</span>
    <span class="n">ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">((</span><span class="n">si</span><span class="o">-</span><span class="n">sf</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="n">sf</span><span class="p">),</span><span class="mi">1</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>

    <span class="c1">#Elapsed time T is [0,inf) and increases monotonely with ratio</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ratio</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">Vtot</span>
    <span class="c1">#Set T in line with air for non-solvents</span>
    <span class="n">T</span><span class="p">[</span><span class="n">Lpol</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:]</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">diff</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">diff</span><span class="p">[</span><span class="n">Lpol</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:]</span>

    <span class="c1"># Add any extra time</span>
    <span class="n">ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">v</span><span class="o">/</span><span class="n">Vtot</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="o">-</span><span class="n">E3</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">mixing</span><span class="o">*</span><span class="n">diff</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">ratio</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">SCALING</span>
    <span class="c1"># Do a cap on T when mixing since you should always be able to stir the vessel</span>
    <span class="c1"># Even if the vessel has been settling for 100 years</span>
    <span class="k">if</span> <span class="n">mixing</span><span class="o">&lt;</span> <span class="o">-</span><span class="mf">1e-4</span><span class="p">:</span>
        <span class="n">T</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">3.278</span><span class="p">)</span>
        <span class="n">T_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="mf">3.278</span><span class="p">)</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="n">dt</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">T</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span><span class="o">&gt;</span><span class="n">T_max</span><span class="p">)</span><span class="o">*</span><span class="n">T_max</span><span class="o">+</span><span class="p">(</span><span class="n">T</span><span class="o">&lt;=</span><span class="n">T_max</span><span class="p">)</span><span class="o">*</span><span class="n">T</span>

    <span class="n">T</span><span class="o">+=</span><span class="n">dt</span>
    <span class="c1">#Make sure Time is &gt;= 0 (0 is fully mixed time)</span>
    <span class="n">T</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>


    <span class="c1">#Update variance</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">Vtot</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">sf</span><span class="o">+</span><span class="p">(</span><span class="n">si</span><span class="o">-</span><span class="n">sf</span><span class="p">)</span><span class="o">*</span><span class="n">g</span>

    <span class="c1">#Math for position vs time:</span>
    <span class="c1">#https://www.desmos.com/calculator/imukub1xzr </span>

    <span class="c1"># A are the volumes used for dissolving</span>
    <span class="n">A</span><span class="o">=</span><span class="n">v</span><span class="p">[:</span><span class="n">Lpol</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

<span class="c1">##############################[Mixing / Separating Solutes]#######################################</span>

    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">C0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span> <span class="p">)</span>

    <span class="c1"># Mixing should always mix at least a bit   </span>
    <span class="k">if</span> <span class="n">mixing</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">solute_mixing</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">t</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">tseparate</span><span class="p">)</span>

    <span class="n">mixing</span><span class="o">+=</span><span class="n">solute_mixing</span>
    <span class="c1"># Check if fully mixed already</span>
    <span class="k">if</span> <span class="n">t</span> <span class="o">+</span> <span class="n">mixing</span> <span class="o">&lt;</span> <span class="n">tmix</span><span class="p">:</span>
        <span class="n">mixing</span> <span class="o">=</span> <span class="n">tmix</span> <span class="o">-</span> <span class="n">t</span>
    <span class="n">t</span> <span class="o">+=</span> <span class="n">mixing</span>


    <span class="n">Scur</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
    <span class="c1"># only do the calculation if there are two or more solvents</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">or</span> <span class="n">A</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">-</span><span class="n">A</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">&lt;</span><span class="mf">1e-12</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">mixing</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-12</span><span class="p">):</span>
    <span class="c1"># Update amount of solute i in each solvent</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>

        <span class="n">Ssum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Scur</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">Ssum</span><span class="o">&lt;</span><span class="mf">1e-6</span><span class="p">:</span>
            <span class="k">continue</span>    

        <span class="c1"># Calculate the relative and weighted polarity terms</span>
        <span class="n">Ldif</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">Ldif0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Lpol</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">Ldif</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Spol</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">Lpol</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">Ldif0</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Spol</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">Lpol</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

        <span class="c1"># Calculate total amount of solute</span>
        
        
        <span class="c1"># Note A*re_weight has the same sum as A</span>
        <span class="n">re_weight</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Spol</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">Lpol</span><span class="p">)</span> <span class="o">/</span> <span class="n">Ldif</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">Ldif0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">*</span> <span class="n">Ldif</span><span class="p">))</span>
        <span class="c1">#coeff for current timestep</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">t_scale</span><span class="o">*</span><span class="p">(</span><span class="n">tmix</span> <span class="o">-</span> <span class="n">t</span><span class="p">))</span>
        <span class="c1">#coeff for prev timestep</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">t_scale</span><span class="o">*</span><span class="p">(</span><span class="n">tmix</span> <span class="o">-</span> <span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">mixing</span><span class="p">)))</span>
        <span class="c1"># Calculate the ideal amount of solute i in each solvent for the current time step</span>
        <span class="n">St</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ssum</span> <span class="o">*</span> <span class="n">A</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">A</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="n">re_weight</span><span class="p">)</span>
        <span class="c1"># Calculate the ideal amount of solute i in each solvent for the previous time step</span>
        <span class="n">St0</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ssum</span> <span class="o">*</span> <span class="n">A</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">A</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">beta</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">beta</span><span class="p">)</span> <span class="o">*</span> <span class="n">re_weight</span><span class="p">)</span>
        <span class="c1">#print(S[i],St0,St,re_weight,mixing,alpha,beta)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">mixing</span> <span class="o">-</span> <span class="n">tmix</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-9</span><span class="p">:</span>
            <span class="c1">#Square of the cosine between the two distributions</span>
            <span class="n">cosine</span> <span class="o">=</span> <span class="p">(</span><span class="n">St0</span><span class="o">*</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">/</span><span class="p">((</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">*</span><span class="p">(</span><span class="n">St</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span><span class="o">**</span><span class="mf">0.5</span>
            <span class="c1"># Moving backwards in time</span>
            <span class="k">if</span> <span class="n">mixing</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="c1">#Make sure mixing always happens reasonably well</span>
                <span class="n">cosine</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">cosine</span><span class="p">,</span><span class="mi">1</span><span class="o">-</span><span class="n">cosine</span><span class="p">)</span>
                <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cosine</span><span class="p">)</span> <span class="o">+</span> <span class="n">St</span><span class="o">*</span><span class="n">cosine</span>
            <span class="c1"># Moving Forwards in time</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#scale cosine to be higher if you wait longer (bad approximation)</span>
                <span class="n">cosine</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">cosine</span><span class="o">**</span><span class="mf">1.5</span><span class="o">*</span><span class="p">(</span><span class="n">mixing</span><span class="o">*</span><span class="n">t_scale</span><span class="o">*</span><span class="mi">5</span><span class="p">)</span><span class="o">**</span><span class="mf">1.5</span><span class="p">),</span><span class="mf">1e-2</span><span class="p">)</span>
                <span class="c1"># Move towards projected step St with cosine step size</span>
                <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cosine</span><span class="p">)</span> <span class="o">+</span> <span class="n">St</span><span class="o">*</span><span class="n">cosine</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">St</span>

    <span class="n">C0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="p">)</span>

    <span class="c1">#Update layer volumes to include their dissolved solutes</span>
    <span class="n">v_layer</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Lpol</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">vol</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">v_solute</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="c1"># Add solute volume to solvent volume</span>
            <span class="n">v_layer</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+=</span><span class="n">vol</span>
            <span class="c1">#reduce amount of air</span>
            <span class="n">v_layer</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-=</span><span class="n">vol</span>

    <span class="c1"># Calculate final layer positions</span>
    <span class="n">means</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">Vtot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">order</span><span class="p">:</span>
        <span class="n">means</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Vtot</span><span class="o">+</span><span class="n">v_layer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">Vtot</span><span class="o">+=</span><span class="n">v_layer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="c1">#update positions</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">means</span><span class="o">+</span><span class="p">(</span><span class="n">Vtot</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="n">means</span><span class="p">)</span><span class="o">*</span><span class="n">g</span>
    <span class="c1"># Adjust variances for dissolved volumes</span>
    <span class="n">sf2</span> <span class="o">=</span> <span class="n">v_layer</span><span class="o">/</span><span class="n">MINVAR</span> 
    <span class="n">var_layer</span> <span class="o">=</span> <span class="n">sf2</span><span class="o">+</span><span class="p">(</span><span class="n">si</span><span class="o">-</span><span class="n">sf2</span><span class="p">)</span><span class="o">*</span><span class="n">g</span>

    <span class="k">return</span> <span class="n">B</span><span class="p">,</span> <span class="n">v_layer</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span><span class="n">C0</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">var_layer</span></div>






<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    
    <span class="n">cc</span><span class="o">.</span><span class="n">compile</span><span class="p">()</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Chris Beeler, Sriram Ganapathi Subramanian, Kyle Sprague, Nouha Chatti, ColinBellinger, Mitchell Shahen, Nicholas Paquin, Mark Baula, Amanuel Dawit, Zihan Yang,Xinkai Li, Mark Crowley, Isaac Tamblyn.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>